# -*- coding: utf-8 -*-

"""
/***************************************************************************
 JapanBasemap
                                 A QGIS plugin
 指定されたベクタに交差(intersect)する範囲内で、指定した地図情報レベルの国土基本図図郭を生成します
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-06-18
        copyright            : (C) 2022 by Epoppo
        email                : poppo.circle@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Epoppo'
__date__ = '2022-06-18'
__copyright__ = '(C) 2022 by Epoppo'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from typing import Any, Dict, Tuple, Union

from qgis import processing
from qgis.core import (QgsCoordinateReferenceSystem, QgsFeatureIterator,
                       QgsFeatureSink, QgsField, QgsFields, QgsProcessing,
                       QgsProcessingAlgorithm, QgsProcessingContext,
                       QgsProcessingException, QgsProcessingFeedback,
                       QgsProcessingParameterBoolean,
                       QgsProcessingParameterCrs, QgsProcessingParameterEnum,
                       QgsProcessingParameterFeatureSink,
                       QgsProcessingParameterFeatureSource, QgsRectangle,
                       QgsVectorLayer, QgsWkbTypes)
from qgis.PyQt.QtCore import QCoreApplication, QVariant


class JapanBasemapAlgorithm(QgsProcessingAlgorithm):
    """国土基本図図郭生成アルゴリズムクラス
    基本的な書き方は下記公式ユーザガイドとAPIドキュメントに書いてあることが全てなので、これに従った書き方を行っていくこと。
    https://docs.qgis.org/3.10/ja/docs/user_manual/processing/scripts.html
    https://qgis.org/pyqgis/3.10/core/QgsProcessingAlgorithm.html
    """

    # パラメータID
    INPUT = "INPUT"
    KIND = "KIND"
    EXTENT = "EXTENT"
    PREDICATE = "PREDICATE"
    INTERSECT = "INTERSECT"
    CHECK_FLAG = "CHECK_FLAG"
    OUTPUT = "OUTPUT"
    OUTPUT_CRS = "OUTPUT_CRS"

    # 予備
    ERROR_NUMBER = -1

    # Enumとして使う。
    BASE_X = 0
    BASE_Y = 1

    # EPSG
    JAPAN_PLANE_RECTANGULAR = {
        "JGD2011": 6668,
        "JGD2000": 2442,
        "Tokyo": 30161,
    }

    # 各地図情報レベルにおける定数部分の定義。
    # 当処理内での計算に用いる為の定義なので、他から呼び出すように作ってないし、当辞書配列の使用方法はエレガントさに欠ける。暇があれば設計を見直すこと。
    # また、後述する処理で順序付きである事を前提とした動かし方をしているので、Python3.6以降を想定。
    # LEVEL: 地図情報レベル
    # AREA_SIZE: 原点(0,0)と各頂点で四角形を作った際のサイズ。計算用。(m)
    # FIGURE_SIZE: 1図郭のサイズ(m)
    # BASE: 名称の継承元("LEVEL")
    # FIGURE_NAME: 図郭の左上にあたる箇所の名称。[x,y]
    # DIVIDE: 各エリアにおける図郭の最大分割数。
    _BASIC_PROPERTY = {
        50000: {
            "LEVEL": 50000,
            "AREA_SIZE": [160000, 300000],
            "FIGURE_SIZE": [40000, 30000],
            "BASE": [50000],
            "FIGURE_NAME": ["A", "A"],
            "DIVIDE": [8, 20],
        },
        5000: {
            "LEVEL": 5000,
            "AREA_SIZE": [40000, 30000],
            "FIGURE_SIZE": [4000, 3000],
            "BASE": [50000, 5000],
            "FIGURE_NAME": ["0", "0"],
            "DIVIDE": [10, 10],
        },
        2500: {
            "LEVEL": 2500,
            "AREA_SIZE": [4000, 3000],
            "FIGURE_SIZE": [2000, 1500],
            "BASE": [50000, 5000, 2500],
            "FIGURE_NAME": ["1"],
            "DIVIDE": [2, 2],
        },
        1000: {
            "LEVEL": 1000,
            "AREA_SIZE": [4000, 3000],
            "FIGURE_SIZE": [800, 600],
            "BASE": [50000, 5000, 1000],
            "FIGURE_NAME": ["A", "0"],
            "DIVIDE": [5, 5],
        },
        500: {
            "LEVEL": 500,
            "AREA_SIZE": [4000, 3000],
            "FIGURE_SIZE": [400, 300],
            "BASE": [50000, 5000, 500],
            "FIGURE_NAME": ["0", "0"],
            "DIVIDE": [10, 10],
        },
        250: {
            "LEVEL": 250,
            "AREA_SIZE": [4000, 3000],
            "FIGURE_SIZE": [200, 150],
            "BASE": [50000, 5000, 250],
            "FIGURE_NAME": ["A", "A"],
            "DIVIDE": [20, 20],
        },
    }

    # 新規フィールド
    # とりあえず出力時の図郭名を代入するために使う。**を使った書き方は見直しできなくなりそうなので使用を控える
    # 新しい属性が欲しければ、下記リストに内容を追加する。
    _MAP_NAME = "MapName"
    _NEW_FIELD = [
        {"name": _MAP_NAME, "type": QVariant.String, "len": 10},
    ]

    def __init__(self):
        super().__init__()

        # 処理内容の選択肢
        self.MESH_TYPE = [self.tr(f"地図情報レベル {lev}") for lev in self._BASIC_PROPERTY.keys()]

    def initAlgorithm(self, config):
        """パラメータの定義を行う
        self.addParameterするとウィンドウをよしなにしてくれて、大変楽ちん

        Args:
            config ([type], optional): [description]. Defaults to None.
        """
        # 入力時CRS(Japan Plane Rectangular のみ許可)
        self.addParameter(
            QgsProcessingParameterCrs(
                self.INPUT, self.tr("生成時CRS\nJGD2011,JGD2000,Tokyo座標系の1~19系のみ生成を許可"), optional=False
            )
        )

        # 処理種別
        self.addParameter(
            QgsProcessingParameterEnum(
                self.KIND, self.tr("処理種別"), options=self.MESH_TYPE, defaultValue=0, optional=False
            )
        )

        # 比較対象となるレイヤ
        self.addParameter(QgsProcessingParameterFeatureSource(self.INTERSECT, self.tr("比較対象の地物があるレイヤ"), optional=False))

        # レイヤと交差する図郭のみ出力する(チェック済みをデフォルトに指定)
        self.addParameter(
            QgsProcessingParameterBoolean(
                self.CHECK_FLAG, self.tr("比較対象レイヤと交差する箇所のみ出力"), defaultValue=1, optional=False
            )
        )

        # OUTPUT(グリッドレイヤ)
        self.addParameter(QgsProcessingParameterFeatureSink(self.OUTPUT, self.tr("出力レイヤ"), optional=False))

    def processAlgorithm(
        self, parameters: Dict[str, Any], context: "QgsProcessingContext", feedback: "QgsProcessingFeedback"
    ) -> Dict[str, "QgsFeatureSink"]:
        """処理の実体
        INPUTに「日本で使用される平面直角座標系の1~19系のいずれかのEPSG」と「処理範囲」を取ることで、
        当該範囲内に交差(intersect)する形の国土基本図図郭gridを生成し、図郭名称を属性テーブルに記載し出力する。

        パラメータからのデータ取得方法や内容の詳細は下記QgsProcessingAlgorithmクラスのAPIドキュメント参照
        https://qgis.org/pyqgis/3.10/core/QgsProcessingAlgorithm.html

        Qgisが所持している他のプロセシングアルゴリズムを多用して、なるべく楽して作る

        Args:
            parameters (dict[str:Any]) : initAlgorithm関数で使用した"INPUT"等の固定文字列をkey、入力値をvalueとして持つ辞書
            context (QgsProcessingContext): 関連するプロジェクトや式のコンテキストなどの設定
            feedback (QgsProcessingFeedback): 現在出力しているウィンドウへのフィードバック用。
                                              プログレスバーの更新やキャンセルボタンの押下時動作などを反映できる

        Returns:
            OUTPUT(dict[QgsFeatureSink,str]): 国土基本図図郭レイヤ
        """

        # 入力された内容の読み込み
        source_crs = self.parameterAsCrs(parameters, self.INPUT, context)  # type: QgsCoordinateReferenceSystem
        source_kind = self.parameterAsEnum(parameters, self.KIND, context)  # type: int
        source_area = self.parameterAsExtent(parameters, self.INTERSECT, context, crs=source_crs)  # type: QgsRectangle
        source_vector = self.parameterAsVectorLayer(parameters, self.INTERSECT, context)  # type: QgsVectorLayer
        is_intersect_check = self.parameterAsBool(parameters, self.CHECK_FLAG, context)  # type: bool

        # 入力されたCRSがJGD2011,JGD2000,Tokyo座標系の1~19系のいずれかであるかの判断
        source_code, source_epsg, *_ = source_crs.authid().split(":")
        if (not "EPSG" == source_code) or (not self.isEPSGToKei(int(source_epsg))):
            raise QgsProcessingException("INPUT_CRS が JGD2000, JGD2011, Tokyo座標における1~19系のいずれでもありません")

        # 系の導出
        source_kei = self.derivedEPSGToKei(int(source_epsg))  # type: int

        # 選択した処理内容を配列の添字から辞書キーに変換
        source_kind = list(self._BASIC_PROPERTY.keys())[source_kind]  # type: int

        # 「選択した地物」にチェックが入っている場合の範囲
        # TODO:QgsProcessingFeatureSourceDefinitionのうまい処理が全くわからん。もっと良い処理方法を思いついたら改修予定
        if hasattr(parameters[self.INTERSECT], "selectedFeaturesOnly") and (
            parameters[self.INTERSECT].selectedFeaturesOnly
        ):
            # 『レイヤの再投影』
            # 詳しい内容は下記コマンドで確認可能
            # processing.algorithmHelp("native:reprojectlayer")
            source_vector = processing.run(
                "native:reprojectlayer",
                {"INPUT": parameters[self.INTERSECT], "TARGET_CRS": source_crs, "OUTPUT": "memory:"},
                context=context,
                feedback=feedback,
            )["OUTPUT"]

            if source_vector is None:
                raise QgsProcessingException("Failed to reproject layer")

            # 選択した地物の範囲を指定
            source_area = source_vector.extent()

        # 国土基本図図郭の範囲外は無視
        if (
            (source_area.xMinimum() < (-1) * self._BASIC_PROPERTY[50000]["AREA_SIZE"][self.BASE_X])
            or (source_area.xMaximum() > self._BASIC_PROPERTY[50000]["AREA_SIZE"][self.BASE_X])
            or (source_area.yMinimum() < (-1) * self._BASIC_PROPERTY[50000]["AREA_SIZE"][self.BASE_Y])
            or (source_area.yMaximum() > self._BASIC_PROPERTY[50000]["AREA_SIZE"][self.BASE_Y])
        ):
            raise QgsProcessingException("INPUT_EXTENT is not coverd by Base map outline")

        # 処理範囲を図郭サイズのn倍の範囲になるよう調整
        figure_x = self._BASIC_PROPERTY[source_kind]["FIGURE_SIZE"][self.BASE_X]
        figure_y = self._BASIC_PROPERTY[source_kind]["FIGURE_SIZE"][self.BASE_Y]

        max_x = (int(source_area.xMaximum() // figure_x) + 1) * figure_x
        max_y = (int(source_area.yMaximum() // figure_y) + 1) * figure_y
        min_x = (int(source_area.xMinimum() // figure_x)) * figure_x
        min_y = (int(source_area.yMinimum() // figure_y)) * figure_y

        # 出力レイヤのフィールドを定義
        fields = QgsFields()
        for newf in self._NEW_FIELD:
            fields.append(QgsField(name=newf["name"], type=newf["type"], len=newf["len"]))

        # 出力レイヤの定義
        # type: Tuple[QgsFeatureSink, str]
        (sink, dest_id) = self.parameterAsSink(
            parameters, self.OUTPUT, context, fields, QgsWkbTypes.Polygon, source_crs
        )

        # 『グリッドを作成』
        # 詳しい内容は下記コマンドで確認可能
        # processing.algorithmHelp("native:creategrid")
        feedback.pushInfo("native:creategrid")
        grid_sink = processing.run(
            "native:creategrid",
            {
                "TYPE": 2,
                "EXTENT": "{},{},{},{}".format(min_x, max_x, min_y, max_y),
                "HSPACING": self._BASIC_PROPERTY[source_kind]["FIGURE_SIZE"][self.BASE_X],
                "VSPACING": self._BASIC_PROPERTY[source_kind]["FIGURE_SIZE"][self.BASE_Y],
                "HOVERLAY": 0,
                "VOVERLAY": 0,
                "CRS": source_crs,
                "OUTPUT": "memory:",
            },
            context=context,
            feedback=feedback,
        )["OUTPUT"]
        if feedback.isCanceled():
            return {}

        if grid_sink is None:
            raise QgsProcessingException("Failed to generate the grid")

        if is_intersect_check:
            # 『空間インデックスを作成』
            # 詳しい内容は下記コマンドで確認可能
            # processing.algorithmHelp("native:createspatialindex")
            feedback.pushInfo("native:createspatialindex")
            processing.run(
                "native:createspatialindex",
                {"INPUT": grid_sink},
                context=context,
                feedback=feedback,
            )

            if feedback.isCanceled():
                return {}

            # 『場所による抽出』
            # 詳しい内容は下記コマンドで確認可能
            # processing.algorithmHelp("native:extractbylocation")
            feedback.pushInfo("native:extractbylocation")
            grid_sink = processing.run(
                "native:extractbylocation",
                {"INPUT": grid_sink, "PREDICATE": 0, "INTERSECT": source_vector, "OUTPUT": "memory:"},
                context=context,
                feedback=feedback,
            )["OUTPUT"]

            if feedback.isCanceled():
                return {}

            if (grid_sink is None) or (grid_sink.featureCount() == 0):
                raise QgsProcessingException("Failed to extract by location")

        # 不要なフィールドの削除と新規フィールドの追加
        feedback.pushInfo("Generate figure numbers")
        grid_sink.startEditing()
        grid_sink.deleteAttributes(attrs=grid_sink.attributeList())
        for newf in self._NEW_FIELD:
            grid_sink.addAttribute(QgsField(name=newf["name"], type=newf["type"], len=newf["len"]))
        grid_sink.commitChanges()

        # フィーチャに名前つけて出力用レイヤへコピー
        total = 100.0 / grid_sink.featureCount()  # type: float
        features = grid_sink.getFeatures()  # type: QgsFeatureIterator

        for current, feature in enumerate(features):
            # キャンセルボタン押下時に中断
            if feedback.isCanceled():
                break

            # 図郭名称の設定
            feature_minx = int(feature.geometry().boundingBox().xMinimum())
            feature_maxy = int(feature.geometry().boundingBox().yMaximum())
            value = self.derivedToFigureName(source_kei, source_kind, feature_minx, feature_maxy)
            feature.setAttribute(name=self._MAP_NAME, value=value)

            # 他処理あれば

            # 出力用レイヤへの追加
            sink.addFeature(feature=feature, flags=QgsFeatureSink.FastInsert)

            # プログレスバーの更新
            feedback.setProgress(int(current * total))

        # 出力
        return {self.OUTPUT: dest_id}

    def derivedToFigureName(self, kei: int, select_level: int, figure_x: int, figure_y: int) -> str:
        """系と地図情報レベルと左上座標の点を投げると、対象の点が属する図郭名称を導出して返す関数。
        地図情報レベル2500の命名だけが例外で気持ち悪い。なんで1から始まるんだ
        Args:
            kei (int)  : 系
            select (int): Qgis上で選択した項番(_BASIC_PROPERTYの選択番に依存)
            figure_x (int): 図郭の左上座標(x)
            figure_y (int): 図郭の左上座標(y)

        Returns:
            figure_name (str): 図郭名称

        使用例
            Qgisの「gridの生成」を行い、フィーチャから取得した左上の座標値をAREAに渡して、名前を返してもらう
            figure_name = convertToFigureName(source_kei, source_kind, AREA["left"], AREA["top"])
        """
        figure_name = str(kei).zfill(2)
        for level in self._BASIC_PROPERTY[select_level]["BASE"]:
            nowp = self._BASIC_PROPERTY[level]
            convert_x = (
                int((nowp["AREA_SIZE"][self.BASE_X] + figure_x) // nowp["FIGURE_SIZE"][self.BASE_X])
                % nowp["DIVIDE"][self.BASE_X]
            )
            convert_y = (
                int((nowp["AREA_SIZE"][self.BASE_Y] - figure_y) // nowp["FIGURE_SIZE"][self.BASE_Y])
                % nowp["DIVIDE"][self.BASE_Y]
            )
            if nowp["LEVEL"] == 2500:
                figure_name += chr(ord(nowp["FIGURE_NAME"][self.BASE_X]) + convert_x + (convert_y * 2))
            else:
                figure_name += chr(ord(nowp["FIGURE_NAME"][self.BASE_Y]) + convert_y) + chr(
                    ord(nowp["FIGURE_NAME"][self.BASE_X]) + convert_x
                )

        return figure_name

    def isEPSGToKei(self, epsg_num: int) -> bool:
        """引数のepsgが平面直角座標系の1~19系であるか否かを判断する関数
        Args:
            epsg_num (int): EPSG番号

        Returns:
            (bool): 1~19系のいずれかであればTrue、そうでなければFalse
        """
        if self.derivedEPSGToKei(epsg_num):
            return True
        return False

    def derivedEPSGToKei(self, epsg_num: int) -> Union[int, bool]:
        """引数のepsgが平面直角座標系の1~19系であれば、その系の数値を返す関数
        Args:
            epsg_num (int): EPSG番号

        Returns:
            (int): 系番号1~19のいずれか(エラー時False)
        """
        # セイウチ演算子使いたい
        for base in self.JAPAN_PLANE_RECTANGULAR.values():
            if 1 <= (epsg_num - base) <= 19:
                return epsg_num - base
        return False

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'japanbasemap'

    def displayName(self):
        """プロセシングツールボックス上での名称"""
        return self.tr("国土基本図図郭生成")

    def shortHelpString(self):
        """アルゴリズムダイアログの右側に表示される短い概要となる為の文章"""
        return self.tr("比較対象の地物として指定されたベクタに交差(intersect)する範囲内で、生成時CRSと処理種別で指定した地図情報レベルの国土基本図図郭を生成します。")

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return ''

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return JapanBasemapAlgorithm()
