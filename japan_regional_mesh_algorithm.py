# -*- coding: utf-8 -*-

"""
/***************************************************************************
 JapanRegionalMesh
                                 A QGIS plugin
 対象範囲内に交差する地域メッシュの生成
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-06-22
        copyright            : (C) 2022 by Epoppo
        email                : poppo.circle@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = "Epoppo"
__date__ = "2022-07-04"
__copyright__ = "(C) 2022 by Epoppo"

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = "$Format:%H$"

from enum import Flag, IntEnum, auto, unique
from typing import Any, Dict, NamedTuple, Tuple, Union

from qgis import processing
from qgis.core import (
    QgsCoordinateReferenceSystem,
    QgsFeatureIterator,
    QgsFeatureSink,
    QgsField,
    QgsFields,
    QgsProcessing,
    QgsProcessingAlgorithm,
    QgsProcessingContext,
    QgsProcessingException,
    QgsProcessingFeedback,
    QgsProcessingParameterEnum,
    QgsProcessingParameterFeatureSink,
    QgsProcessingParameterFeatureSource,
    QgsRectangle,
    QgsWkbTypes,
)
from qgis.PyQt.QtCore import QCoreApplication, QVariant

# メッシュの分割で割り算の計算を行う部分は、必ず割り切れる以上fractionsとか使うべき？遅いけど。
# 度、度分秒、_MESH_PROPERTYの中身辺りはそれぞれdataclassesで纏めてもっと賢い実装にするべきな気がするけど、Qgis3.4より古いバージョンはPython3.7に対応していないのでパス
# 同様にFinal、セイウチ演算子、match-case等も禁止。singledispatchは大丈夫
# Qgis 3.0~3.3.xの使用するpython3.6は、EOLを迎えているのでもういいのでは？とかみたいなのは後人にお任せ

# japan_basemapと併せ、列挙型とはいえ数字で辞書を作る当手法に対して「目が腐る」、「闇の実装」などの暖かいお言葉を頂きました。暗黒面のパワーは素晴らしいぞ
# 実際EnumはHasshableだから問題ないとはいえ、このやり方だとdataclassesへと容易に置き換えられない気がするので、今後のメンテ考えたら良くない実装。
# Python3.6未満で動く、もうちょい賢いやり方が思いついて気力があれば書き直します。


@unique
class CrsProperty(IntEnum):
    """測地系のパターン
    ここに記載された定数の順番(0~)でQgisの処理種別項目の順番に表示されます。
    auto()は実装依存なので、大事を取って使用禁止
    """

    JGD2011 = 0
    JGD2000 = 1
    TOKYO_DATUM = 2


@unique
class MeshPattern(IntEnum):
    """メッシュのパターン
    ここに記載された定数の順番(0~)でQgisの処理種別項目の順番に表示されます。
    auto()は実装依存なので、大事を取って使用禁止
    """

    FIRST_MESH = 0
    SECOND_MESH = 1
    FIVE_TIMES_MESH_BASED_ON_THIRD_MESH = 2
    TWO_TIMES_MESH_BASED_ON_THIRD_MESH = 3
    THIRD_MESH = 4
    FOURTH_MESH = 5
    FIFTH_MESH = 6
    SIXTH_MESH = 7
    ONE_TENTH_MESH_BASED_ON_THIRD_MESH = 8


class NamingRule(Flag):
    """名前付けルール
    TSK: 緯度経度からの算出、4図郭で左下を基点として反時計回りに1~4の割り振り、元をn個に割る、2の倍数で算出して末尾に5を足す
    """

    FIRST_MESH = auto()
    DIVIDE_XPARTS = auto()
    DIVIDE_SPECIAL_4PARTS = auto()
    TWO_TIME_MESH = auto()


# dataclassesはPython3.7(Qgis3.4)からなので使用禁止
# 使用箇所が非常に限定されているので、全部QgsRectangleでやり切るべきな気がしてならない。
class RectData(NamedTuple):
    lat_minimum: Union[int, float]
    lat_maximum: Union[int, float]
    lon_minimum: Union[int, float]
    lon_maximum: Union[int, float]


class JapanRegionalMeshAlgorithm(QgsProcessingAlgorithm):
    # パラメータID
    INPUT = "INPUT"
    KIND = "KIND"
    INTERSECT = "INTERSECT"
    OUTPUT = "OUTPUT"

    # 処理を日本国内に限定するための緯度経度。世界メッシュの生成までは業務的に不要そうなので。
    LAT_MINIMUM = 20.0
    LAT_MAXIMUM = 46.0
    LON_MINIMUM = 122.0
    LON_MAXIMUM = 154.0

    # Enumとして使う。
    BASE_LAT = 0
    BASE_LON = 1

    # CRSとデータ表示用プロパティ
    # description(str): [unique] ウィジェット上で選択する際の名前。
    # EPSG(int): [unique] 処理に使用するEPSG。CRS(QgsCoordinationReferenceSystem)を定義する際に使用
    _CRS_PROPERTY = {
        CrsProperty.JGD2011: {
            "description": "世界測地系 JGD2011(EPSG:6668)",
            "EPSG": 6668,
        },
        CrsProperty.JGD2000: {
            "description": "世界測地系 JGD2000(EPSG:4612)",
            "EPSG": 4612,
        },
        CrsProperty.TOKYO_DATUM: {
            "description": "日本測地系 TokyoDatum(EPSG:4301)",
            "EPSG": 4301,
        },
    }

    # 各メッシュにおける定数部分の定義。基本的にベースをn分割するだけなので、分割ルールだけで動かす試みを取る
    # 新種のメッシュを足すときは、MeshPatternとこの_MESH_PROPERTYに定義を突っ込んで実装完了。
    #
    # description(str): [unique] ウィジェット上で選択する際の名前。
    # parent(Optional[MeshPattern]): [unique]default=None 分割元となるMeshPetternを記載
    # divide(Tuple[int, int]): [unique]default=(1,1) 親のメッシュを(lat分割数, lon分割数)の「個数」に分割する
    # naming_rule(NamingRule): [unique] 分割手法。該当する内容をNamingRuleクラス内から選んで記載
    # figure_sec_size(Tuple[Union[int, float], Union[int, float]]): 分割元となる"秒数"を記載。基本的に一番の親になるプロパティのみに記載。
    _MESH_PROPERTY = {
        MeshPattern.FIRST_MESH: {
            "description": "第1次地域区画(1次メッシュ, 一辺約80km): 4桁",
            "parent": None,
            "divide": (1, 1),
            "naming_rule": NamingRule.FIRST_MESH,
            "figure_sec_size": (2400, 3600),
        },
        MeshPattern.SECOND_MESH: {
            "description": "第2次地域区画(2次メッシュ, 一辺約10km): 6桁",
            "parent": MeshPattern.FIRST_MESH,
            "divide": (8, 8),
            "naming_rule": NamingRule.DIVIDE_XPARTS,
        },
        MeshPattern.THIRD_MESH: {
            "description": "基準地域メッシュ(3次メッシュ, 一辺約1km): 8桁",
            "parent": MeshPattern.SECOND_MESH,
            "divide": (10, 10),
            "naming_rule": NamingRule.DIVIDE_XPARTS,
        },
        MeshPattern.FOURTH_MESH: {
            "description": "2分の1地域メッシュ(4次メッシュ, 一辺約500m): 9桁",
            "parent": MeshPattern.THIRD_MESH,
            "divide": (2, 2),
            "naming_rule": NamingRule.DIVIDE_SPECIAL_4PARTS,
        },
        MeshPattern.FIFTH_MESH: {
            "description": "4分の1地域メッシュ(5次メッシュ, 一辺約250m): 10桁",
            "parent": MeshPattern.FOURTH_MESH,
            "divide": (2, 2),
            "naming_rule": NamingRule.DIVIDE_SPECIAL_4PARTS,
        },
        MeshPattern.SIXTH_MESH: {
            "description": "8分の1地域メッシュ(6次メッシュ, 一辺約125m): 11桁",
            "parent": MeshPattern.FIFTH_MESH,
            "divide": (2, 2),
            "naming_rule": NamingRule.DIVIDE_SPECIAL_4PARTS,
        },
        MeshPattern.TWO_TIMES_MESH_BASED_ON_THIRD_MESH: {
            "description": "2倍地域メッシュ(統合地域メッシュ 一辺約2km): 9桁",
            "parent": MeshPattern.SECOND_MESH,
            "divide": (5, 5),
            "naming_rule": NamingRule.TWO_TIME_MESH,
        },
        MeshPattern.FIVE_TIMES_MESH_BASED_ON_THIRD_MESH: {
            "description": "5倍地域メッシュ(統合地域メッシュ 一辺約5km): 7桁",
            "parent": MeshPattern.SECOND_MESH,
            "divide": (2, 2),
            "naming_rule": NamingRule.DIVIDE_SPECIAL_4PARTS,
        },
        MeshPattern.ONE_TENTH_MESH_BASED_ON_THIRD_MESH: {
            "description": "3次メッシュ1/10細分区画(一辺約100m): 10桁",
            "parent": MeshPattern.THIRD_MESH,
            "divide": (10, 10),
            "naming_rule": NamingRule.DIVIDE_XPARTS,
        },
    }

    # 文字列型にするべきではないのかもしれない。使用感聞いて変更するか、選択式にするかも。
    _MESH_NAME = "MeshName"
    _NEW_FIELD = [
        {"name": _MESH_NAME, "type": QVariant.String, "len": 20},
    ]

    def __init__(self):
        super().__init__()
        # 処理内容の選択肢
        self.MESH_CRS = [self.tr(f"{self._CRS_PROPERTY[num]['description']}") for num in CrsProperty]
        self.MESH_TYPE = [self.tr(f"{self._MESH_PROPERTY[num]['description']}") for num in MeshPattern]

    def initAlgorithm(self, config) -> None:
        """パラメータの定義を行う
        self.addParameterするとウィンドウをよしなにしてくれて、大変楽ちん

        Args:
            config ([type], optional): [description]. Defaults to None.
        """
        # 入力するCRS
        self.addParameter(
            QgsProcessingParameterEnum(
                self.INPUT,
                self.tr("生成するメッシュのCRS"),
                options=self.MESH_CRS,
                defaultValue=int(CrsProperty.JGD2000),
                optional=False,
            )
        )

        # 処理種別
        self.addParameter(
            QgsProcessingParameterEnum(
                self.KIND,
                self.tr("処理種別"),
                options=self.MESH_TYPE,
                defaultValue=int(MeshPattern.THIRD_MESH),
                optional=False,
            )
        )

        # 比較対象となるレイヤ
        self.addParameter(QgsProcessingParameterFeatureSource(self.INTERSECT, self.tr("比較対象の地物があるレイヤ"), optional=False))

        # OUTPUT(グリッドレイヤ)
        self.addParameter(QgsProcessingParameterFeatureSink(self.OUTPUT, self.tr("出力レイヤ"), optional=False))
        return None

    def processAlgorithm(
        self, parameters: Dict[str, Any], context: "QgsProcessingContext", feedback: "QgsProcessingFeedback"
    ) -> Dict[str, "QgsFeatureSink"]:
        """処理の実体
        INPUTに「出力先EPSG」と「処理範囲」を取ることで、
        当該範囲内に交差(intersect)する形の地域メッシュを生成し、ジオメトリ情報から名称を逆引きして属性テーブルに記載しフィーチャを出力する。

        パラメータからのデータ取得方法や内容の詳細は下記QgsProcessingAlgorithmクラスのAPIドキュメント参照
        https://qgis.org/pyqgis/3.10/core/QgsProcessingAlgorithm.html

        Qgisが所持している他のプロセシングアルゴリズムを多用して、なるべく楽して作る

        Args:
            parameters (dict[str:Any]) : initAlgorithm関数で使用した"INPUT"等の固定文字列をkey、入力値をvalueとして持つ辞書
            context (QgsProcessingContext): 関連するプロジェクトや式のコンテキストなどの設定
            feedback (QgsProcessingFeedback): 現在出力しているウィンドウへのフィードバック用。
                                              プログレスバーの更新やキャンセルボタンの押下時動作などを反映できる

        Returns:
            OUTPUT(dict[str,QgsFeatureSink]): 地域メッシュに対応するグリッドレイヤ
        """
        # 入力された内容の読み込み
        source_crs_property = CrsProperty(self.parameterAsEnum(parameters, self.INPUT, context))  # type: CrsProperty
        source_mesh_pattern = MeshPattern(self.parameterAsEnum(parameters, self.KIND, context))  # type: MeshPattern

        # レイヤのCRSを設定
        source_crs = QgsCoordinateReferenceSystem(f"EPSG:{self._CRS_PROPERTY[source_crs_property]['EPSG']}")  # type: QgsCoordinateReferenceSystem

        # 『レイヤの再投影』
        # 詳しい内容は下記コマンドで確認可能
        # processing.algorithmHelp("native:reprojectlayer")
        feedback.pushInfo("範囲元となるベクタの再投影")
        feedback.pushInfo("native:reprojectlayer")
        source_vector = processing.run(
            "native:reprojectlayer",
            {"INPUT": parameters[self.INTERSECT], "TARGET_CRS": source_crs, "OUTPUT": "memory:"},
            context=context,
            feedback=feedback,
        )["OUTPUT"]

        if feedback.isCanceled():
            return {}

        if source_vector is None:
            raise QgsProcessingException("Failed to reproject layer")

        # (再投影した)入力地物の範囲を確認する
        input_rect = self.makeQgsRectangleToRectData(source_vector.extent())  # type: RectData

        if not self.isExtentWithinJapan(input_rect):
            raise QgsProcessingException("INPUT_EXTENT is not coverd by Base map outline")

        # 分割量の確認
        figure_sec_size = self.fromFigureSecSize(source_mesh_pattern)  # type: Tuple[Union[int,float], Union[int,float]]
        figure_size = tuple(map(self._convertSecToAngle, figure_sec_size))  # type: Tuple[float,float]

        # 処理範囲を指定されたメッシュ情報のn倍の範囲になるよう調整
        process_rect = self.makeProcessRectData(input_rect, source_mesh_pattern)  # type: RectData

        # 出力レイヤのフィールドを定義
        fields = QgsFields()
        for newf in self._NEW_FIELD:
            fields.append(QgsField(name=newf["name"], type=newf["type"], len=newf["len"]))

        # 出力レイヤの定義
        # type: Tuple[str, QgsFeatureSink]
        (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT, context, fields, QgsWkbTypes.Polygon, source_crs)

        # 『グリッドを作成』
        # 詳しい内容は下記コマンドで確認可能
        # processing.algorithmHelp("native:creategrid")
        feedback.pushInfo("調整した範囲内でグリッドを作成")
        feedback.pushInfo("native:creategrid")
        grid_sink = processing.run(
            "native:creategrid",
            {
                "TYPE": 2,
                "EXTENT": f"{process_rect.lon_minimum},{process_rect.lon_maximum},{process_rect.lat_minimum},{process_rect.lat_maximum}",
                "HSPACING": figure_size[self.BASE_LON],
                "VSPACING": figure_size[self.BASE_LAT],
                "HOVERLAY": 0,
                "VOVERLAY": 0,
                "CRS": source_crs,
                "OUTPUT": "memory:",
            },
            context=context,
            feedback=feedback,
        )["OUTPUT"]

        if feedback.isCanceled():
            return {}

        if grid_sink is None:
            raise QgsProcessingException("Failed to generate the grid")

        # 『空間インデックスを作成』
        # 詳しい内容は下記コマンドで確認可能
        # processing.algorithmHelp("native:createspatialindex")
        feedback.pushInfo("空間インデックスを作成")
        feedback.pushInfo("native:createspatialindex")
        processing.run(
            "native:createspatialindex",
            {"INPUT": grid_sink},
            context=context,
            feedback=feedback,
        )

        if feedback.isCanceled():
            return {}

        # 『場所による抽出』
        # 詳しい内容は下記コマンドで確認可能
        # processing.algorithmHelp("native:extractbylocation")
        feedback.pushInfo("場所による抽出")
        feedback.pushInfo("native:extractbylocation")
        grid_sink = processing.run(
            "native:extractbylocation",
            {"INPUT": grid_sink, "PREDICATE": 0, "INTERSECT": source_vector, "OUTPUT": "memory:"},
            context=context,
            feedback=feedback,
        )["OUTPUT"]

        if feedback.isCanceled():
            return {}

        if (grid_sink is None) or (grid_sink.featureCount() == 0):
            raise QgsProcessingException("Failed to extract by location")

        # 不要なフィールドの削除と新規フィールドの追加
        feedback.pushInfo("各メッシュ名を算出して新規レイヤにコピー開始")
        grid_sink.startEditing()
        grid_sink.deleteAttributes(attrs=grid_sink.attributeList())
        for newf in self._NEW_FIELD:
            grid_sink.addAttribute(QgsField(name=newf["name"], type=newf["type"], len=newf["len"]))
        grid_sink.commitChanges()

        # フィーチャに名前つけて出力用レイヤへコピー
        total = 100.0 / grid_sink.featureCount()  # type: float
        features = grid_sink.getFeatures()  # type: QgsFeatureIterator

        for current, feature in enumerate(features):
            # キャンセルボタン押下時に終了
            if feedback.isCanceled():
                return {}

            # 図郭名称の設定
            feature_center_lat = feature.geometry().centroid().asPoint().y()
            feature_center_lon = feature.geometry().centroid().asPoint().x()
            value = self.deriveFigureNameFromLatLon(feature_center_lat, feature_center_lon, source_mesh_pattern)
            feature.setAttribute(name=self._MESH_NAME, value=value)

            # 他処理あれば

            # 出力用レイヤへの追加
            sink.addFeature(feature=feature, flags=QgsFeatureSink.FastInsert)

            # プログレスバーの更新
            feedback.setProgress(int(current * total))

        # 出力
        return {self.OUTPUT: dest_id}

    def isExtentWithinJapan(self, src_rect: RectData) -> bool:
        """受け取った範囲が日本国内に納まっているかの確認

        Args:
            src_rect (QgsRectangle): ソースの持つ範囲情報

        Returns:
            (bool): 範囲内であればTrue, そうでなければFalse
        """
        if (
            (src_rect.lat_minimum < self.LAT_MINIMUM)
            or (src_rect.lat_maximum > self.LAT_MAXIMUM)
            or (src_rect.lon_minimum < self.LON_MINIMUM)
            or (src_rect.lon_maximum > self.LON_MAXIMUM)
        ):
            return False
        return True

    def makeQgsRectangleToRectData(self, src_rect: QgsRectangle) -> RectData:
        """QgsRectangleに存在するBountingBox(四角形で囲える範囲)から、
        緯度経度の最小/最大情報をRectDataに代入して返す。
        ぶっちゃけこんな事する必要ないのはそうなんですけど、緯度,経度とy,xがすぐごっちゃになっちゃうので混乱防止のため。

        Args:
            src_rect(QgsRectangle): ソースの持つ範囲情報

        Returns:
            dst_rect(RectData): ソースの持っていた範囲(緯度min, 緯度max, 経度min, 経度max)

        """
        dst_rect = RectData(
            lat_minimum=src_rect.yMinimum(),
            lat_maximum=src_rect.yMaximum(),
            lon_minimum=src_rect.xMinimum(),
            lon_maximum=src_rect.xMaximum(),
        )

        return dst_rect

    def newRectData(self, lat_min: Union[int, float], lat_max: Union[int, float], lon_min: Union[int, float], lon_max: Union[int, float]) -> RectData:
        """RectDataの設定を行う関数。多分使わない。
        西経、東経とか北緯、南緯とかも考えてません。あくまで日本国内での使用に留まる

        Args:
            lat_min (Union[int, float]): 緯度最小値
            lat_max (Union[int, float]): 緯度最大値
            lon_min (Union[int, float]): 経度最小値
            lon_max (Union[int, float]): 経度最大値

        Returns:
            RectData: 処理範囲
        """
        dest_rect = RectData(lat_minimum=lat_min, lat_maximum=lat_max, lon_minimum=lon_min, lon_maximum=lon_max)
        return dest_rect

    def makeProcessRectData(self, input_rect: RectData, mesh_pattern: MeshPattern) -> RectData:
        """入力元範囲とメッシュパターンから、処理に必要そうな範囲をTuple(緯度,経度)で返す。

        Args:
            src_rect(QgsRectangle): ソースの持つ範囲情報
            mesh_pattern(MeshPattern): 入力されたメッシュパターン

        Returns:
            process_rect(RectData): 処理を行うべき範囲(緯度min, 緯度max, 経度min, 経度max)
        """
        figure_sec_size = self.fromFigureSecSize(mesh_pattern)
        figure_size = tuple(map(self._convertSecToAngle, figure_sec_size))

        lat_min = ((input_rect.lat_minimum // figure_size[self.BASE_LAT])) * figure_size[self.BASE_LAT]
        lat_max = ((input_rect.lat_maximum // figure_size[self.BASE_LAT]) + 1) * figure_size[self.BASE_LAT]
        lon_min = ((input_rect.lon_minimum // figure_size[self.BASE_LON])) * figure_size[self.BASE_LON]
        lon_max = ((input_rect.lon_maximum // figure_size[self.BASE_LON]) + 1) * figure_size[self.BASE_LON]

        process_rect = self.newRectData(lat_min=lat_min, lat_max=lat_max, lon_min=lon_min, lon_max=lon_max)
        return process_rect

    def deriveFigureNameFromLatLon(self, lat: Union[int, float], lon: Union[int, float], mesh_pattern: MeshPattern) -> str:
        """緯度経度からメッシュコードを割り出す

        Args:
            lat (Union[int, float]): 任意座標(10進数の度)
            lon (Union[int, float]): 任意座標(10進数の度)
            pat (MeshPattern): メッシュパターン

        Returns:
            figure_name(str): 入力された点が所属しているメッシュコード
        """
        lat_sec = self._convertAngleToSec(lat)
        lon_sec = self._convertAngleToSec(lon)
        figure_name = self.deriveFigureNameFromLatLonSec(lat_sec, lon_sec, mesh_pattern)
        return figure_name

    def deriveFigureNameFromLatLonSec(self, lat_sec: Union[int, float], lon_sec: Union[int, float], mesh_pattern: MeshPattern) -> str:
        """秒で表示された緯度と経度から、所属するメッシュコードを導出する過労死担当クラス

        Args:
            lat (Union[int, float]): 任意座標(秒)
            lon (Union[int, float]): 任意座標(秒)
            pat (MeshPattern): メッシュパターン

        Returns:
            figure_name(str): 入力された点が所属しているメッシュコード
        """
        figure_name = ""
        lat_tmp = lat_sec
        lon_tmp = lon_sec
        mesh_pattern_ancestors = self.retrieveMeshAncestors(mesh_pattern)
        now_figure_size = self.fromGansoFigureSecSize(mesh_pattern)

        # UGLY:
        # むちゃくちゃだけど、全部10万倍とかにしてInt型で処理するように書き換えた方が100次メッシュとか出てきた時に安心なのでは
        for mesh_pattern in mesh_pattern_ancestors:
            now_pattern = self._MESH_PROPERTY[mesh_pattern]
            naming_rule = now_pattern["naming_rule"]
            mesh_divide = now_pattern["divide"]

            # 図郭をn等分した際に所属する位置と次回の計算用データの算出
            lat_name, lat_tmp = divmod(lat_tmp, now_figure_size[self.BASE_LAT] / mesh_divide[self.BASE_LAT])
            lon_name, lon_tmp = divmod(lon_tmp, now_figure_size[self.BASE_LON] / mesh_divide[self.BASE_LON])

            # 所属位置からの名づけ
            if naming_rule == NamingRule.FIRST_MESH:
                figure_name += str(int(lat_name) % 100).zfill(2) + str(int(lon_name) % 100).zfill(2)

            elif naming_rule == NamingRule.DIVIDE_XPARTS:
                figure_name += str(int(lat_name)) + str(int(lon_name))

            elif naming_rule == NamingRule.DIVIDE_SPECIAL_4PARTS:
                figure_name += str(int(lat_name * 2 + lon_name + 1))

            elif naming_rule == NamingRule.TWO_TIME_MESH:
                figure_name += str(int(lat_name) * 2) + str(int(lon_name) * 2) + str(5)

            else:
                # 未定義動作時
                pass

            now_figure_size = [now_fig / divide for now_fig, divide in zip(now_figure_size, mesh_divide)]

        return figure_name

    def retrieveMeshAncestors(self, mesh_pattern: MeshPattern) -> Tuple[MeshPattern, ...]:
        """MESH_PROPERTYのparent要素を取ってきたものを昇順にして返す

        Args:
            mesh_pattern (MeshPattern): 地域メッシュ種別

        Returns:
            ancestors_list (Tuple[MeshPattern, ...]): _MESH_PROPERTY上のparentを辿り、最も祖となるMeshPatternから入力MeshPatternまでを順に入れたもの
        """
        ancestors_list = []
        now_pattern = mesh_pattern
        while True:
            ancestors_list.append(now_pattern)
            now_pattern = self._MESH_PROPERTY[now_pattern]["parent"]
            if now_pattern is None:
                ancestors_list.reverse()
                break
        return tuple(ancestors_list)

    def productDivide(self, mesh_pattern: MeshPattern) -> Tuple[int, int]:
        """親のメッシュから選択したメッシュまでの分割量を掛け合わせて返す

        Args:
            mesh_pattern(MeshPattern): 地域メッシュ種別

        Returns:
            divide (Tuple[int, int]): 分割数の積[緯度側分割数, 経度側分割数]
        """
        total_divide = [1, 1]
        ancestors = self.retrieveMeshAncestors(mesh_pattern)
        for ancestor in ancestors:
            now_pattern_divide = self._MESH_PROPERTY[ancestor]["divide"]
            total_divide = [now_div * total_div for now_div, total_div in zip(now_pattern_divide, total_divide)]
        return tuple(total_divide)

    def fromGansoFigureSecSize(self, mesh_pattern: MeshPattern) -> Tuple[Union[int, float], Union[int, float]]:
        """指定した地域メッシュ種別の最も祖にあたる地域メッシュ種別の(緯度, 経度)を秒で表現した大きさを返す
        基本1次メッシュが入ることになるけど、それ以外を祖とした場合のものを作るかもしれないので。

        Args:
            mesh_pattern (MeshPattern): 地域メッシュ種別

        Return:
            ganso_figure_sec_size(Tuple[Union[int, float], Union[int, float]]): 祖となる地域メッシュ種別の1メッシュの緯度,経度の大きさを秒で表したもの
        """
        ganso_figure_sec_size = [1, 1]
        ancestors = self.retrieveMeshAncestors(mesh_pattern)
        ganso = self._MESH_PROPERTY[ancestors[0]]
        if ("figure_sec_size" in ganso) or (ganso["figure_sec_size"] is not None):
            # TIPS: 現在のMESH_PROPERTYの構成を変えた場合、必ず触る事
            ganso_figure_sec_size = ganso["figure_sec_size"]
        return tuple(ganso_figure_sec_size)

    def fromFigureSecSize(self, mesh_pattern: MeshPattern) -> Tuple[Union[int, float], Union[int, float]]:
        """指定した地域メッシュ種別(緯度, 経度)を秒で表現した大きさを計算して返す

        Args:
            mesh_pattern (MeshPattern): 地域メッシュ種別

        Return:
            figure_sec_size(Tuple[Union[int, float], Union[int, float]]): 入力した地域メッシュ種別の1メッシュの緯度,経度の大きさを秒で表したもの

        """
        ganso_figure_sec_size = self.fromGansoFigureSecSize(mesh_pattern)
        total_divide = self.productDivide(mesh_pattern)

        # UGLY: わざわざ余りを求めるような重たい処理やってまで判定するようなことか？
        figure_sec_size = []
        for fig_size, total_div in zip(ganso_figure_sec_size, total_divide):
            if fig_size % total_div == 0:
                figure_sec_size.append(fig_size // total_div)
            else:
                figure_sec_size.append(fig_size / total_div)
        return tuple(figure_sec_size)

    def _convertAngleToSec(self, angle: Union[int, float]) -> Union[int, float]:
        """度⇒秒"""
        return angle * 3600

    def _convertSecToAngle(self, sec: Union[int, float]) -> float:
        """秒⇒度"""
        return sec / 3600

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return "japanregionalmesh"

    def displayName(self):
        """プロセシングツールボックス上での名称"""
        return self.tr("地域メッシュ生成")

    def shortHelpString(self):
        """アルゴリズムダイアログの右側に表示される短い概要となる為の文章"""
        return self.tr(
            "比較対象の地物として指定されたベクタに交差(intersect)する範囲内で、処理種別で指定した地域メッシュを生成します。\n\n \
            生成は世界測地系であるJGD2011とJGD2000、日本測地系であるTokyoDatumの三種類の系で、日本の国土にかかる第1次地域区画(緯度20-46°、経度122-154°)の内側に限る。\n\n \
            処理種別にはJIS X 0410で定義される標準地域メッシュ(1~6次メッシュと2次メッシュを元に分割した2倍, 5倍メッシュ)、加えて統計等で利用される事の多い100mメッシュ(3次メッシュ1/10細分区画)を生成可能"
        )

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return ""

    def tr(self, string):
        return QCoreApplication.translate("Processing", string)

    def createInstance(self):
        return JapanRegionalMeshAlgorithm()
